const libjsmacho = (() => {
  function toUint8Array(input) {
    if (input instanceof Uint8Array) return input;
    if (input instanceof ArrayBuffer) return new Uint8Array(input);
    if (input instanceof Blob) throw new Error('Blob not supported directly');
    throw new Error('Unsupported buffer input');
  }
  class Reader {
    constructor(buf, le = true) {
      this.buf = buf instanceof ArrayBuffer ? new Uint8Array(buf) : buf;
      this.dv = new DataView(this.buf.buffer, this.buf.byteOffset, this.buf.byteLength);
      this.le = le;
    }
    u8(off) {
      return this.dv.getUint8(off);
    }
    u16(off) {
      return this.dv.getUint16(off, this.le);
    }
    u32(off) {
      return this.dv.getUint32(off, this.le);
    }
    u64(off) {
      const low = this.u32(off);
      const high = this.u32(off + 4);
      return BigInt(high) << 32n | BigInt(low);
    }
    bytes(off, len) {
      return new Uint8Array(this.buf.buffer, this.buf.byteOffset + off, len);
    }
    slice(off, len) {
      return this.buf.slice(off, off + len);
    }
    length() {
      return this.buf.length;
    }
  }
  class Writer {
    constructor(size) {
      this.buf = new Uint8Array(size);
      this.dv = new DataView(this.buf.buffer);
      this.offset = 0;
    }
    setU8(off, v) {
      this.dv.setUint8(off, v);
    }
    setU32(off, v) {
      this.dv.setUint32(off, v, true);
    }
    setU64(off, v) {
      const low = Number(BigInt(v) & 0xffffffffn);
      const high = Number((BigInt(v) >> 32n) & 0xffffffffn);
      this.setU32(off, low);
      this.setU32(off + 4, high);
    }
    writeBytes(off, bytes) {
      this.buf.set(bytes, off);
    }
    toArrayBuffer() {
      return this.buf.buffer.slice(this.buf.byteOffset, this.buf.byteOffset + this.buf.byteLength);
    }
  }
  const MAGIC = {
    MH_MAGIC: 0xfeedface,
    MH_CIGAM: 0xcefaedfe,
    MH_MAGIC_64: 0xfeedfacf,
    MH_CIGAM_64: 0xcffaedfe,
    FAT_MAGIC: 0xcafebabe,
    FAT_CIGAM: 0xbebafeca
  };
  function parseHeader(buf) {
    const r = new Reader(buf);
    const magic = r.u32(0);
    let le = true;
    let is64 = false;
    if (magic === MAGIC.MH_MAGIC) le = true; else if (magic === MAGIC.MH_CIGAM) le = false; else if (magic === MAGIC.MH_MAGIC_64) { le = true; is64 = true; } else if (magic === MAGIC.MH_CIGAM_64) { le = false; is64 = true; } else throw new Error('Not a Mach-O header');
    const dv = new DataView(r.buf.buffer, r.buf.byteOffset, r.buf.byteLength);
    const readU32 = (off)=>dv.getUint32(off, le);
    const readU16 = (off)=>dv.getUint16(off, le);
    const cputype = readU32(4);
    const cpusub = readU32(8);
    const filetype = readU32(12);
    const ncmds = readU32(16);
    const sizeofcmds = readU32(20);
    const flags = readU32(24);
    const idx = is64 ? 32 : 28;
    return {
      magic,
      le,
      is64,
      cputype,
      cpusub,
      filetype,
      ncmds,
      sizeofcmds,
      flags,
      headerSize: idx
    };
  }
  function buildHeader(obj, writer) {
    const dv = writer.dv;
    dv.setUint32(0, obj.magic, true);
    dv.setUint32(4, obj.cputype, true);
    dv.setUint32(8, obj.cpusub, true);
    dv.setUint32(12, obj.filetype, true);
    dv.setUint32(16, obj.ncmds, true);
    dv.setUint32(20, obj.sizeofcmds, true);
    dv.setUint32(24, obj.flags, true);
    if (obj.is64) dv.setUint32(28, 0, true);
  }
  const LC = {
    SEGMENT: 0x1,
    SYMTAB: 0x2,
    DYSYMTAB: 0xb,
    LOAD_DYLIB: 0xc,
    ID_DYLIB: 0xd,
    SEGMENT_64: 0x19,
    UUID: 0x1b,
    RPATH: 0x1c,
    CODE_SIGNATURE: 0x1d,
    REEXPORT_DYLIB: 0x1f,
    ENCRYPTION_INFO_64: 0x2c,
    MAIN: 0x80000028,
    DYLD_INFO_ONLY: 0x80000022
  };
  function parseLoadCommands(buf, header) {
    const r = new Reader(buf, header.le);
    let off = header.headerSize;
    const cmds = [];
    for (let i = 0; i < header.ncmds; i++) {
      const cmd = r.u32(off);
      const cmdsize = r.u32(off + 4);
      const data = r.slice(off, cmdsize);
      cmds.push({ cmd, cmdsize, off, data });
      off += cmdsize;
    }
    return cmds;
  }
  function findCommand(cmds, type) {
    return cmds.filter(c => c.cmd === type);
  }
  function replaceCommand(cmds, type, newCmd) {
    for (let i = 0; i < cmds.length; i++) if (cmds[i].cmd === type) { cmds[i] = newCmd; return; }
    cmds.push(newCmd);
  }
  function parseSegments(buf, header, cmds) {
    const r = new Reader(buf, header.le);
    const segs = [];
    for (const lc of cmds) {
      if (lc.cmd === 0x19 || lc.cmd === 0x1) {
        const is64 = header.is64 && lc.cmd === 0x19;
        const name = String.fromCharCode.apply(null, Array.from(lc.data.slice(8, 24))).replace(/\0.*$/,'');
        const vmaddr = is64 ? Number(r.u64(lc.off + 24)) : r.u32(lc.off + 24);
        const vmsize = is64 ? Number(r.u64(lc.off + 32)) : r.u32(lc.off + 28);
        const fileoff = is64 ? Number(r.u64(lc.off + 40)) : r.u32(lc.off + 32);
        const filesize = is64 ? Number(r.u64(lc.off + 48)) : r.u32(lc.off + 36);
        const nsects = is64 ? r.u32(lc.off + 64) : r.u32(lc.off + 48);
        const sects = [];
        let sectOff = lc.off + (is64 ? 72 : 56);
        for (let i = 0; i < nsects; i++) {
          const n = String.fromCharCode.apply(null, Array.from(r.bytes(sectOff, 16))).replace(/\0.*$/,'');
          const segname = String.fromCharCode.apply(null, Array.from(r.bytes(sectOff + 16, 16))).replace(/\0.*$/,'');
          const addr = is64 ? Number(r.u64(sectOff + 32)) : r.u32(sectOff + 32);
          const size = is64 ? Number(r.u64(sectOff + 40)) : r.u32(sectOff + 36);
          const offset = r.u32(sectOff + (is64 ? 56 : 44));
          sects.push({ name: n, segname, addr, size, offset });
          sectOff += is64 ? 80 : 68;
        }
        segs.push({ name, vmaddr, vmsize, fileoff, filesize, nsects, sects, headerOff: lc.off, cmdsize: lc.cmdsize });
      }
    }
    return segs;
  }
  function findCodeSignature(cmds) {
    for (const c of cmds) if (c.cmd === 0x1d) return c;
    return null;
  }
  function stripCodeSignature(cmds) {
    const i = cmds.findIndex(c => c.cmd === 0x1d);
    if (i === -1) return false;
    cmds.splice(i, 1);
    return true;
  }
  function buildEmptyCodeSignature() {
    const buf = new Uint8Array(8);
    const dv = new DataView(buf.buffer);
    dv.setUint32(0, 0x1d, true);
    dv.setUint32(4, 8, true);
    return buf;
  }
  function isFat(buf) {
    const dv = new DataView(buf.buffer, buf.byteOffset, 4);
    const magic = dv.getUint32(0, false);
    return magic === 0xcafebabe || magic === 0xbebafeca;
  }
  function parseFat(buf) {
    const dv = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    const magic = dv.getUint32(0, false);
    const nfat = dv.getUint32(4, false);
    const slices = [];
    let off = 8;
    for (let i = 0; i < nfat; i++) {
      const cputype = dv.getUint32(off, false);
      const cpusub = dv.getUint32(off + 4, false);
      const offset = dv.getUint32(off + 8, false);
      const size = dv.getUint32(off + 12, false);
      const align = dv.getUint32(off + 16, false);
      slices.push({ cputype, cpusub, offset, size, align });
      off += 20;
    }
    return { magic, nfat, slices };
  }
  function extractSlice(buf, slice) {
    return buf.slice(slice.offset, slice.offset + slice.size);
  }
  function align(v, a) {
    return Math.ceil(v / a) * a;
  }
  function uint8ToArrayBuffer(u8) {
    return u8.buffer.slice(u8.byteOffset, u8.byteOffset + u8.byteLength);
  }
  class MachOFile {
    constructor(input) {
      this._raw = toUint8Array(input);
      this._isFat = isFat(this._raw);
      if (this._isFat) {
        this._fat = parseFat(this._raw);
        this._slices = this._fat.slices.map(s => extractSlice(this._raw, s));
        this.selectedIndex = 0;
        this._slice = this._slices[0];
        this._initSlice();
      } else {
        this._slice = this._raw;
        this._initSlice();
      }
    }
    _initSlice() {
      this.header = parseHeader(this._slice);
      this.loadCommands = parseLoadCommands(this._slice, this.header);
      this.segments = parseSegments(this._slice, this.header, this.loadCommands);
    }
    isFat() {
      return this._isFat;
    }
    getSlices() {
      return this._slices || [this._slice];
    }
    selectSlice(i) {
      if (!this._slices) throw new Error('Not a fat binary');
      if (i < 0 || i >= this._slices.length) throw new Error('Index out of range');
      this.selectedIndex = i;
      this._slice = this._slices[i];
      this._initSlice();
    }
    getLoadCommands() {
      return this.loadCommands;
    }
    getSegments() {
      return this.segments;
    }
    findCodeSignature() {
      return findCodeSignature(this.loadCommands);
    }
    stripCodeSignature() {
      return stripCodeSignature(this.loadCommands);
    }
    addPlaceholderCodeSignature() {
      this.loadCommands.push({ cmd: 0x1d, cmdsize: 8, off: 0, data: buildEmptyCodeSignature() });
    }
    setUUID(uuid) {
      const buf = new Uint8Array(16);
      const hex = uuid.replace(/-/g,'');
      for (let i = 0; i < 16; i++) buf[i] = parseInt(hex.substr(i*2,2),16);
      const uuidCmd = this.loadCommands.find(c=>c.cmd===0x1b);
      if (uuidCmd) {
        const off = uuidCmd.off + 8;
        this._writeBytesToSlice(off, buf);
      } else {
        const arr = new Uint8Array(8+16);
        const dv = new DataView(arr.buffer);
        dv.setUint32(0,0x1b,true);
        dv.setUint32(4,24,true);
        arr.set(buf,8);
        this.loadCommands.push({ cmd: 0x1b, cmdsize: 24, off: 0, data: arr });
      }
    }
    injectSegment(name, bytes) {
      const n = Math.min(16, name.length);
      const segname = new Uint8Array(16);
      for (let i=0;i<n;i++) segname[i]=name.charCodeAt(i);
      const segbuf = new Uint8Array(72 + bytes.length);
      const dv = new DataView(segbuf.buffer);
      dv.setUint32(0,0x19,true);
      dv.setUint32(4,segbuf.length,true);
      segbuf.set(segname,8);
      const fileoff = align(Math.floor(Math.random()*0x1000),0x1000);
      dv.setUint32(40, fileoff, true);
      dv.setUint32(48, bytes.length, true);
      segbuf.set(bytes, 72);
      this.loadCommands.push({ cmd: 0x19, cmdsize: segbuf.length, off: 0, data: segbuf });
      this.segments.push({ name, vmaddr:0, vmsize:bytes.length, fileoff, filesize:bytes.length, nsects:0, sects:[], headerOff:0, cmdsize:segbuf.length });
      this._appendToSlice(fileoff, bytes);
    }
    injectSection(segment, name, bytes) {
      const seg = this.segments.find(s=>s.name===segment);
      if (!seg) throw new Error('Segment not found');
      const sectname = name.slice(0,16);
      const fileoff = align(this._slice.length, 0x1000);
      const newSect = { name: sectname, segname: segment, addr:0, size:bytes.length, offset: fileoff };
      seg.sects.push(newSect);
      seg.nsects += 1;
      seg.vmsize += bytes.length;
      seg.filesize += bytes.length;
      this._appendToSlice(fileoff, bytes);
    }
    patch(offset, data) {
      this._writeBytesToSlice(offset, data);
    }
    build() {
      if (this._isFat) {
        const outSlices = [];
        for (let i = 0; i < this._slices.length; i++) {
          if (i === this.selectedIndex) outSlices.push(this._buildSlice()); else outSlices.push(this._slices[i]);
        }
        const total = outSlices.reduce((a,b)=>a+b.byteLength,0) + 8 + this._fat.slices.length*20;
        const out = new Uint8Array(total);
        const dv = new DataView(out.buffer);
        dv.setUint32(0,0xcafebabe,false);
        dv.setUint32(4,this._fat.nfat,false);
        let off = 8;
        let current = 8 + this._fat.nfat*20;
        for (let i=0;i<this._fat.slices.length;i++) {
          const s = this._fat.slices[i];
          dv.setUint32(off, s.cputype, false);
          dv.setUint32(off+4, s.cpusub, false);
          dv.setUint32(off+8, current, false);
          dv.setUint32(off+12, outSlices[i].byteLength, false);
          dv.setUint32(off+16, s.align, false);
          off += 20;
          out.set(new Uint8Array(outSlices[i]), current);
          current += outSlices[i].byteLength;
        }
        return out.buffer;
      } else {
        return this._buildSlice();
      }
    }
    _buildSlice() {
      const base = new Uint8Array(this._slice);
      return base.buffer;
    }
    _writeBytesToSlice(off, bytes) {
      const arr = new Uint8Array(this._slice);
      arr.set(bytes, off);
      this._slice = arr;
      if (this._isFat) this._slices[this.selectedIndex] = this._slice;
    }
    _appendToSlice(off, bytes) {
      const curr = new Uint8Array(this._slice);
      const need = off + bytes.length;
      let out;
      if (curr.length >= need) {
        out = curr;
      } else {
        out = new Uint8Array(need);
        out.set(curr,0);
      }
      out.set(bytes, off);
      this._slice = out;
      if (this._isFat) this._slices[this.selectedIndex] = this._slice;
    }
    static randomUUID() {
      const a = new Uint8Array(16);
      if (typeof crypto !== 'undefined' && crypto.getRandomValues) crypto.getRandomValues(a); else {
        for (let i=0;i<16;i++) a[i]=Math.floor(Math.random()*256);
      }
      a[6] = (a[6] & 0x0f) | 0x40;
      a[8] = (a[8] & 0x3f) | 0x80;
      const s = Array.from(a).map(b=>('0'+b.toString(16)).slice(-2)).join('');
      return `${s.substr(0,8)}-${s.substr(8,4)}-${s.substr(12,4)}-${s.substr(16,4)}-${s.substr(20,12)}`;
    }
  }
  class MachOFat {
    constructor(buffer) {
      this.buf = toUint8Array(buffer);
      if (!isFat(this.buf)) throw new Error('Not a fat binary');
      this.info = parseFat(this.buf);
    }
    getSlices() {
      return this.info.slices.map(s => extractSlice(this.buf, s));
    }
  }
  return { MachOFile, MachOFat };
})();
export const MachOFile = libjsmacho.MachOFile;
export const MachOFat = libjsmacho.MachOFat;
export default libjsmacho;
